// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use crate::Host;
use csv::ReaderBuilder;
use std::collections::HashMap;
use std::fs::File;
use std::path::PathBuf;

/// A Host implementation that reads data from CSV files.
pub struct CsvHost {
    /// Map hashed relation ID -> File path
    file_map: HashMap<i32, PathBuf>,

    /// Active iterators: ID -> (Reader, Current Record)
    iters: HashMap<i32, (csv::Reader<File>, csv::StringRecord)>,

    next_iter_id: i32,
}

impl CsvHost {
    pub fn new() -> Self {
        Self {
            file_map: HashMap::new(),
            iters: HashMap::new(),
            next_iter_id: 1, // 0 is reserved for null
        }
    }

    /// Register a CSV file for a relation.
    /// `rel_name` is hashed to match the ID generated by `mangle-codegen`.
    pub fn add_file(&mut self, rel_name: &str, path: PathBuf) {
        let id = hash_name(rel_name);
        self.file_map.insert(id, path);
    }
}

// Helper (duplicated from tests, ideally shared)
fn hash_name(name: &str) -> i32 {
    let mut hash: u32 = 5381;
    for c in name.bytes() {
        hash = ((hash << 5).wrapping_add(hash)).wrapping_add(c as u32);
    }
    hash as i32
}

impl Host for CsvHost {
    fn scan_start(&mut self, rel_id: i32) -> i32 {
        if let Some(path) = self.file_map.get(&rel_id) {
            match ReaderBuilder::new().has_headers(false).from_path(path) {
                Ok(reader) => {
                    let id = self.next_iter_id;
                    self.next_iter_id += 1;
                    // Initialize with empty record
                    self.iters.insert(id, (reader, csv::StringRecord::new()));
                    return id;
                }
                Err(e) => {
                    eprintln!("Failed to open CSV {:?}: {}", path, e);
                    return 0;
                }
            }
        }
        eprintln!("Relation ID {} not found in CsvHost", rel_id);
        0
    }

    fn scan_next(&mut self, iter_id: i32) -> i32 {
        if let Some((reader, record)) = self.iters.get_mut(&iter_id) {
            // Read into the reusable record
            match reader.read_record(record) {
                Ok(true) => {
                    // Record populated. Return iter_id as the tuple pointer.
                    // This is valid because we only access the *current* row.
                    return iter_id;
                }
                Ok(false) => {
                    // EOF
                    return 0;
                }
                Err(e) => {
                    eprintln!("CSV parse error: {}", e);
                    return 0;
                }
            }
        }
        0
    }

    fn get_col(&mut self, tuple_ptr: i32, col_idx: i32) -> i64 {
        // tuple_ptr is iter_id
        if let Some((_, record)) = self.iters.get(&tuple_ptr) {
            if let Some(val_str) = record.get(col_idx as usize) {
                // For now, assume integer data
                return val_str.parse::<i64>().unwrap_or(0);
            }
        }
        0
    }

    fn insert(&mut self, _rel_id: i32, _val: i64) {
        // CsvHost is currently read-only
        eprintln!("Warning: CsvHost insert not supported");
    }

    fn scan_delta_start(&mut self, _rel_id: i32) -> i32 {
        0
    }

    fn scan_index_start(&mut self, _rel_id: i32, _col_idx: i32, _val: i64) -> i32 {
        0
    }

    fn scan_aggregate_start(&mut self, _rel_id: i32, _description: Vec<i32>) -> i32 {
        0
    }

    fn merge_deltas(&mut self) -> i32 {
        0
    }

    fn debuglog(&mut self, _val: i64) {}
}
